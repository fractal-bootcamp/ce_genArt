"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/material.tsx":
/*!******************************!*\
  !*** ./src/app/material.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoiseShaderMaterial: function() { return /* binding */ NoiseShaderMaterial; }\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n// Declare this file as client-side code\n/* __next_internal_client_entry_do_not_use__ NoiseShaderMaterial auto */  // Allows us to use custom materials in R3F\n // Helper to create shader materials\n // Main Three.js library\n// Create a custom shader material with three parts: uniforms, vertex shader, and fragment shader\nconst NoiseShaderMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_0__.shaderMaterial)(// 1. Uniforms: Variables that can be updated from JavaScript\n{\n    time: 0,\n    color: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0.0, 0.0, 0.0),\n    positionIndex: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0),\n    totalCubes: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(50, 50),\n    depthIndex: 0,\n    speed: 0.5,\n    intensity: 0.3\n}, \"\\n    // Declare varying variables to pass data to fragment shader\\n    varying vec2 vUv;            // UV coordinates for texturing\\n    varying vec3 vNormal;        // Surface normals for lighting\\n    varying vec3 vViewPosition;  // Camera-relative position\\n    varying vec3 vWorldPosition; // World-space position\\n    \\n    void main() {\\n      // Pass UV coordinates to fragment shader\\n      vUv = uv;\\n      \\n      // Calculate and normalize surface normal\\n      vNormal = normalize(normalMatrix * normal);\\n      \\n      // Calculate world position for lighting\\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n      vWorldPosition = worldPosition.xyz;\\n      \\n      // Calculate view-space position\\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n      vViewPosition = -mvPosition.xyz;\\n      \\n      // Set final vertex position\\n      gl_Position = projectionMatrix * mvPosition;\\n    }\\n  \", \"\\n    // Declare uniforms that we'll update from JavaScript\\n    uniform float time;          // Animation time\\n    uniform float speed;         // Animation speed control\\n    uniform float intensity;     // Lighting intensity\\n    uniform vec3 color;          // Base color\\n    uniform vec2 positionIndex;  // Grid position\\n    uniform vec2 totalCubes;     // Grid size\\n    uniform float depthIndex;    // Depth layer\\n\\n    // Receive varying variables from vertex shader\\n    varying vec2 vUv;\\n    varying vec3 vNormal;\\n    varying vec3 vViewPosition;\\n    varying vec3 vWorldPosition;\\n\\n    // Pseudo-random noise function\\n    float noise(vec2 p) {\\n      return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123);\\n    }\\n\\n    void main() {\\n      // Normalize vectors for lighting calculations\\n      vec3 normal = normalize(vNormal);\\n      vec3 viewDir = normalize(vViewPosition);\\n      \\n      // Create animated UV coordinates\\n      vec2 uv = vUv;\\n      uv.x += sin(time * speed) * 0.5;\\n      uv.y += cos(time * speed) * 0.5;\\n\\n      // Define colors for each depth layer\\n      vec3 colors[3] = vec3[3](\\n        vec3(0.8, 0.0, 0.0),    // Red for first layer\\n        vec3(0.0, 0.8, 0.0),    // Green for second layer\\n        vec3(0.0, 0.0, 0.8)     // Blue for third layer\\n      );\\n\\n      // Define secondary colors for gradient\\n      vec3 colors2[3] = vec3[3](\\n        vec3(1.0, 0.5, 0.0),    // Orange\\n        vec3(0.0, 1.0, 0.5),    // Lime\\n        vec3(0.5, 0.0, 1.0)     // Purple\\n      );\\n\\n      // Select colors based on depth layer\\n      vec3 color1 = colors[int(depthIndex)];\\n      vec3 color2 = colors2[int(depthIndex)];\\n      vec3 color = mix(color1, color2, uv.x);\\n\\n      // Calculate lighting\\n      vec3 lightPosition = vec3(90.0, 10.0, 20.0);\\n      vec3 lightDir = normalize(lightPosition - vWorldPosition);\\n      \\n      // Calculate diffuse lighting\\n      float diff = max(dot(normal, lightDir), 0.0);\\n      vec3 diffuse = color * diff;\\n      \\n      // Calculate ambient lighting using intensity uniform\\n      vec3 ambient = color * intensity;\\n      \\n      // Calculate specular highlights\\n      vec3 reflectDir = reflect(-lightDir, normal);\\n      float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n      vec3 specular = vec3(0.5) * spec;\\n      \\n      // Combine all lighting components\\n      vec3 finalColor = ambient + diffuse + specular;\\n      \\n      // Output final color with full opacity\\n      gl_FragColor = vec4(finalColor, 1.0);\\n    }\\n  \");\n// Extend directly with NoiseShaderMaterial\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n    NoiseShaderMaterial\n});\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0ZXJpYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3Q0FBd0M7eUVBR0ksQ0FBQywyQ0FBMkM7QUFFckMsQ0FBQyxvQ0FBb0M7QUFDekQsQ0FBQyx3QkFBd0I7QUFFeEQsaUdBQWlHO0FBQ2pHLE1BQU1HLHNCQUFzQkYsaUVBQWNBLENBQ3hDLDZEQUE2RDtBQUM3RDtJQUNFRyxNQUFNO0lBQ05DLE9BQU8sSUFBSUgsd0NBQVcsQ0FBQyxLQUFLLEtBQUs7SUFDakNLLGVBQWUsSUFBSUwsMENBQWEsQ0FBQyxHQUFHO0lBQ3BDTyxZQUFZLElBQUlQLDBDQUFhLENBQUMsSUFBSTtJQUNsQ1EsWUFBWTtJQUNaQyxPQUFPO0lBQ1BDLFdBQVc7QUFDYixHQUdZLDg2QkE0QkE7QUEyRWQsMkNBQTJDO0FBQzNDWixxREFBTUEsQ0FBQztJQUFFRztBQUFvQjtBQVdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvbWF0ZXJpYWwudHN4P2M5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVjbGFyZSB0aGlzIGZpbGUgYXMgY2xpZW50LXNpZGUgY29kZVxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZmliZXJcIjsgLy8gQWxsb3dzIHVzIHRvIHVzZSBjdXN0b20gbWF0ZXJpYWxzIGluIFIzRlxuaW1wb3J0IHR5cGUgeyBSZWFjdFRocmVlRmliZXIgfSBmcm9tIFwiQHJlYWN0LXRocmVlL2ZpYmVyXCI7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZHJlaVwiOyAvLyBIZWxwZXIgdG8gY3JlYXRlIHNoYWRlciBtYXRlcmlhbHNcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiOyAvLyBNYWluIFRocmVlLmpzIGxpYnJhcnlcblxuLy8gQ3JlYXRlIGEgY3VzdG9tIHNoYWRlciBtYXRlcmlhbCB3aXRoIHRocmVlIHBhcnRzOiB1bmlmb3JtcywgdmVydGV4IHNoYWRlciwgYW5kIGZyYWdtZW50IHNoYWRlclxuY29uc3QgTm9pc2VTaGFkZXJNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICAvLyAxLiBVbmlmb3JtczogVmFyaWFibGVzIHRoYXQgY2FuIGJlIHVwZGF0ZWQgZnJvbSBKYXZhU2NyaXB0XG4gIHtcbiAgICB0aW1lOiAwLCAvLyBGb3IgYW5pbWF0aW9uc1xuICAgIGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoMC4wLCAwLjAsIDAuMCksIC8vIEJhc2UgY29sb3IgKFJHQilcbiAgICBwb3NpdGlvbkluZGV4OiBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKSwgLy8gQ3VycmVudCBjdWJlJ3MgcG9zaXRpb24gaW4gZ3JpZFxuICAgIHRvdGFsQ3ViZXM6IG5ldyBUSFJFRS5WZWN0b3IyKDUwLCA1MCksIC8vIEdyaWQgZGltZW5zaW9uc1xuICAgIGRlcHRoSW5kZXg6IDAsIC8vIFotbGF5ZXIgaW5kZXhcbiAgICBzcGVlZDogMC41LCAvLyBBbmltYXRpb24gc3BlZWQgY29udHJvbFxuICAgIGludGVuc2l0eTogMC4zLCAvLyBMaWdodGluZyBpbnRlbnNpdHkgY29udHJvbFxuICB9LFxuXG4gIC8vIDIuIFZlcnRleCBTaGFkZXI6IFByb2Nlc3NlcyBlYWNoIHZlcnRleCBvZiB0aGUgZ2VvbWV0cnlcbiAgLyogZ2xzbCAqLyBgXG4gICAgLy8gRGVjbGFyZSB2YXJ5aW5nIHZhcmlhYmxlcyB0byBwYXNzIGRhdGEgdG8gZnJhZ21lbnQgc2hhZGVyXG4gICAgdmFyeWluZyB2ZWMyIHZVdjsgICAgICAgICAgICAvLyBVViBjb29yZGluYXRlcyBmb3IgdGV4dHVyaW5nXG4gICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7ICAgICAgICAvLyBTdXJmYWNlIG5vcm1hbHMgZm9yIGxpZ2h0aW5nXG4gICAgdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247ICAvLyBDYW1lcmEtcmVsYXRpdmUgcG9zaXRpb25cbiAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247IC8vIFdvcmxkLXNwYWNlIHBvc2l0aW9uXG4gICAgXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gUGFzcyBVViBjb29yZGluYXRlcyB0byBmcmFnbWVudCBzaGFkZXJcbiAgICAgIHZVdiA9IHV2O1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYW5kIG5vcm1hbGl6ZSBzdXJmYWNlIG5vcm1hbFxuICAgICAgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgd29ybGQgcG9zaXRpb24gZm9yIGxpZ2h0aW5nXG4gICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdmlldy1zcGFjZSBwb3NpdGlvblxuICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICAgIHZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XG4gICAgICBcbiAgICAgIC8vIFNldCBmaW5hbCB2ZXJ0ZXggcG9zaXRpb25cbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XG4gICAgfVxuICBgLFxuXG4gIC8vIDMuIEZyYWdtZW50IFNoYWRlcjogQ29sb3JzIGVhY2ggcGl4ZWxcbiAgLyogZ2xzbCAqLyBgXG4gICAgLy8gRGVjbGFyZSB1bmlmb3JtcyB0aGF0IHdlJ2xsIHVwZGF0ZSBmcm9tIEphdmFTY3JpcHRcbiAgICB1bmlmb3JtIGZsb2F0IHRpbWU7ICAgICAgICAgIC8vIEFuaW1hdGlvbiB0aW1lXG4gICAgdW5pZm9ybSBmbG9hdCBzcGVlZDsgICAgICAgICAvLyBBbmltYXRpb24gc3BlZWQgY29udHJvbFxuICAgIHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5OyAgICAgLy8gTGlnaHRpbmcgaW50ZW5zaXR5XG4gICAgdW5pZm9ybSB2ZWMzIGNvbG9yOyAgICAgICAgICAvLyBCYXNlIGNvbG9yXG4gICAgdW5pZm9ybSB2ZWMyIHBvc2l0aW9uSW5kZXg7ICAvLyBHcmlkIHBvc2l0aW9uXG4gICAgdW5pZm9ybSB2ZWMyIHRvdGFsQ3ViZXM7ICAgICAvLyBHcmlkIHNpemVcbiAgICB1bmlmb3JtIGZsb2F0IGRlcHRoSW5kZXg7ICAgIC8vIERlcHRoIGxheWVyXG5cbiAgICAvLyBSZWNlaXZlIHZhcnlpbmcgdmFyaWFibGVzIGZyb20gdmVydGV4IHNoYWRlclxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XG4gICAgdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuXG4gICAgLy8gUHNldWRvLXJhbmRvbSBub2lzZSBmdW5jdGlvblxuICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkge1xuICAgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QocC54eSwgdmVjMigxMi45ODk4LDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSB2ZWN0b3JzIGZvciBsaWdodGluZyBjYWxjdWxhdGlvbnNcbiAgICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKHZOb3JtYWwpO1xuICAgICAgdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKHZWaWV3UG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYW5pbWF0ZWQgVVYgY29vcmRpbmF0ZXNcbiAgICAgIHZlYzIgdXYgPSB2VXY7XG4gICAgICB1di54ICs9IHNpbih0aW1lICogc3BlZWQpICogMC41O1xuICAgICAgdXYueSArPSBjb3ModGltZSAqIHNwZWVkKSAqIDAuNTtcblxuICAgICAgLy8gRGVmaW5lIGNvbG9ycyBmb3IgZWFjaCBkZXB0aCBsYXllclxuICAgICAgdmVjMyBjb2xvcnNbM10gPSB2ZWMzWzNdKFxuICAgICAgICB2ZWMzKDAuOCwgMC4wLCAwLjApLCAgICAvLyBSZWQgZm9yIGZpcnN0IGxheWVyXG4gICAgICAgIHZlYzMoMC4wLCAwLjgsIDAuMCksICAgIC8vIEdyZWVuIGZvciBzZWNvbmQgbGF5ZXJcbiAgICAgICAgdmVjMygwLjAsIDAuMCwgMC44KSAgICAgLy8gQmx1ZSBmb3IgdGhpcmQgbGF5ZXJcbiAgICAgICk7XG5cbiAgICAgIC8vIERlZmluZSBzZWNvbmRhcnkgY29sb3JzIGZvciBncmFkaWVudFxuICAgICAgdmVjMyBjb2xvcnMyWzNdID0gdmVjM1szXShcbiAgICAgICAgdmVjMygxLjAsIDAuNSwgMC4wKSwgICAgLy8gT3JhbmdlXG4gICAgICAgIHZlYzMoMC4wLCAxLjAsIDAuNSksICAgIC8vIExpbWVcbiAgICAgICAgdmVjMygwLjUsIDAuMCwgMS4wKSAgICAgLy8gUHVycGxlXG4gICAgICApO1xuXG4gICAgICAvLyBTZWxlY3QgY29sb3JzIGJhc2VkIG9uIGRlcHRoIGxheWVyXG4gICAgICB2ZWMzIGNvbG9yMSA9IGNvbG9yc1tpbnQoZGVwdGhJbmRleCldO1xuICAgICAgdmVjMyBjb2xvcjIgPSBjb2xvcnMyW2ludChkZXB0aEluZGV4KV07XG4gICAgICB2ZWMzIGNvbG9yID0gbWl4KGNvbG9yMSwgY29sb3IyLCB1di54KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGxpZ2h0aW5nXG4gICAgICB2ZWMzIGxpZ2h0UG9zaXRpb24gPSB2ZWMzKDkwLjAsIDEwLjAsIDIwLjApO1xuICAgICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvc2l0aW9uIC0gdldvcmxkUG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlmZnVzZSBsaWdodGluZ1xuICAgICAgZmxvYXQgZGlmZiA9IG1heChkb3Qobm9ybWFsLCBsaWdodERpciksIDAuMCk7XG4gICAgICB2ZWMzIGRpZmZ1c2UgPSBjb2xvciAqIGRpZmY7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBhbWJpZW50IGxpZ2h0aW5nIHVzaW5nIGludGVuc2l0eSB1bmlmb3JtXG4gICAgICB2ZWMzIGFtYmllbnQgPSBjb2xvciAqIGludGVuc2l0eTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHNwZWN1bGFyIGhpZ2hsaWdodHNcbiAgICAgIHZlYzMgcmVmbGVjdERpciA9IHJlZmxlY3QoLWxpZ2h0RGlyLCBub3JtYWwpO1xuICAgICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHZpZXdEaXIsIHJlZmxlY3REaXIpLCAwLjApLCAzMi4wKTtcbiAgICAgIHZlYzMgc3BlY3VsYXIgPSB2ZWMzKDAuNSkgKiBzcGVjO1xuICAgICAgXG4gICAgICAvLyBDb21iaW5lIGFsbCBsaWdodGluZyBjb21wb25lbnRzXG4gICAgICB2ZWMzIGZpbmFsQ29sb3IgPSBhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyO1xuICAgICAgXG4gICAgICAvLyBPdXRwdXQgZmluYWwgY29sb3Igd2l0aCBmdWxsIG9wYWNpdHlcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgMS4wKTtcbiAgICB9XG4gIGBcbik7XG5cbi8vIEV4dGVuZCBkaXJlY3RseSB3aXRoIE5vaXNlU2hhZGVyTWF0ZXJpYWxcbmV4dGVuZCh7IE5vaXNlU2hhZGVyTWF0ZXJpYWwgfSk7XG5cbi8vIFR5cGVTY3JpcHQgc3VwcG9ydFxuZGVjbGFyZSBnbG9iYWwge1xuICBuYW1lc3BhY2UgSlNYIHtcbiAgICBpbnRlcmZhY2UgSW50cmluc2ljRWxlbWVudHMge1xuICAgICAgbm9pc2VTaGFkZXJNYXRlcmlhbDogYW55OyAvLyBTaW1wbGlmaWVkIHR5cGUgZm9yIG5vd1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBOb2lzZVNoYWRlck1hdGVyaWFsIH07XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwic2hhZGVyTWF0ZXJpYWwiLCJUSFJFRSIsIk5vaXNlU2hhZGVyTWF0ZXJpYWwiLCJ0aW1lIiwiY29sb3IiLCJDb2xvciIsInBvc2l0aW9uSW5kZXgiLCJWZWN0b3IyIiwidG90YWxDdWJlcyIsImRlcHRoSW5kZXgiLCJzcGVlZCIsImludGVuc2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/material.tsx\n"));

/***/ })

});