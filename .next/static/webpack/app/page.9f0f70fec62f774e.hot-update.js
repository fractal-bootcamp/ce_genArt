"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/material.tsx":
/*!******************************!*\
  !*** ./src/app/material.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoiseShaderMaterial: function() { return /* binding */ NoiseShaderMaterial; }\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n// materials.tsx\n/* __next_internal_client_entry_do_not_use__ NoiseShaderMaterial auto */ // Import necessary dependencies\n\n\n\n// Create a shader material for noise effect\n// shaderMaterial takes three arguments: uniforms, vertex shader, and fragment shader\nconst NoiseShaderMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_0__.shaderMaterial)(// 1. Uniforms: values passed from JS to shader\n{\n    time: 0,\n    color: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0.0, 0.0, 0.0),\n    positionIndex: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0),\n    totalCubes: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(50, 50),\n    depthIndex: 0\n}, \"\\n  varying vec2 vUv;                             // UV coords for textures& 2d effects \\n  varying vec3 vNormal;                         // surface norms for lighting calculations\\n  varying vec3 vViewPosition;                   // cam-relative position - view-dependent effects \\n  varying vec3 vWorldPosition;                  // world space position \\n  \\n  void main() {\\n    vUv = uv;                                   // pass UV coords \\n    vNormal = normalize(normalMatrix * normal); // calculate normals \\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);     // calc world position for lights \\n    vWorldPosition = worldPosition.xyz;\\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);    // calc view space position \\n    vViewPosition = -mvPosition.xyz;\\n    gl_Position = projectionMatrix * mvPosition;                // set final vertex position \\n  }\\n\", \"\\n    uniform float time;\\n    uniform vec2 positionIndex;\\n    uniform vec2 totalCubes;  // Make sure uniform is declared\\n    uniform float depthIndex;\\n\\n    varying vec2 vUv;\\n    varying vec3 vNormal;\\n    varying vec3 vViewPosition;\\n    varying vec3 vWorldPosition;\\n\\n    float noise(vec2 p) {                                        // creates random noise \\n      return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123);\\n    }\\n\\n    \\n    vec3 getBaseColor(vec2 position, float depth) {             // generate color based off position & depth \\n    vec2 normalizedPos = position / totalCubes;                 // convert grid to 0-1 range \\n\\n// define the colors for each depth layer \\n    vec3 colors[3] = vec3[3](\\n        vec3(0.0, 0.5, 0.3),  // layer 1\\n        vec3(0.4, 0.0, 0.8),  // layer 2 (fixed 0.0. to 0.0)\\n        vec3(0.8, 0.0, 0.0)   // layer 3\\n      );\\n\\n// get the base color for the current depth \\n      vec3 baseColor1 = colors[int(depth)];\\n    // lighter variations \\n      vec3 baseColor2 = baseColor1 + vec3(0.2, 0.2, 0.2);\\n      vec3 baseColor3 = baseColor2 + vec3(0.2, 0.2, 0.2);\\n      \\n// create the gradients \\n      vec3 horizontalGradient = mix(baseColor1, baseColor2, normalizedPos.x);\\n      vec3 verticalGradient = mix(baseColor2, baseColor3, normalizedPos.y);\\n\\n      return mix(horizontalGradient, verticalGradient, 0.5);\\n    }\\n\\n\\n\\n    void main() {\\n\\n    \\n// 1- basic setup: prepare normal and view vectors for lighting \\n      vec3 normal = normalize(vNormal);\\n      vec3 viewDir = normalize(vViewPosition);\\n      \\n// 2- COLOR GEN!!__________________________________________________________________\\n// add noise to base color \\n      vec3 baseColor = getBaseColor(positionIndex, depthIndex);\\n      float n = noise(vUv * 10.0 + time);                       // animate noise \\n      \\n      vec3 lighterColor = baseColor + vec3(0.2);\\n      vec3 color = mix(baseColor, lighterColor, n);\\n\\n// 3- light position: calculate lights \\n      vec3 lightPosition = vec3(90.0, 10.0, 20.0);\\n      vec3 lightDir = normalize(lightPosition - vWorldPosition);\\n      \\n// 4- diffuse lighting: how light affects surface \\n      float diff = max(dot(normal, lightDir), 0.0);\\n      vec3 diffuse = color * diff;\\n      \\n// 5- address ambient lighting \\n      vec3 ambient = color * 0.3;\\n      \\n// 6- specular highlights and refelctions \\n      vec3 reflectDir = reflect(-lightDir, normal);\\n      float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\\n      vec3 specular = vec3(0.5) * spec;\\n    \\n// 7 - composition: combine all lighting components \\n      vec3 finalColor = ambient + diffuse + specular;   \\n// output final color with alpha=1.0 \\n      gl_FragColor = vec4(finalColor, 1.0);\\n    }\\n  \");\n// make material avaibale in React Three Fiber\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n    NoiseShaderMaterial\n});\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0ZXJpYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxnQkFBZ0I7eUVBR2hCLGdDQUFnQztBQUNZO0FBQ087QUFDcEI7QUFFL0IsNENBQTRDO0FBQzVDLHFGQUFxRjtBQUNyRixNQUFNRyxzQkFBc0JGLGlFQUFjQSxDQUN4QywrQ0FBK0M7QUFDL0M7SUFDRUcsTUFBTTtJQUNOQyxPQUFPLElBQUlILHdDQUFXLENBQUMsS0FBSyxLQUFLO0lBQ2pDSyxlQUFlLElBQUlMLDBDQUFhLENBQUMsR0FBRztJQUNwQ08sWUFBWSxJQUFJUCwwQ0FBYSxDQUFDLElBQUk7SUFDbENRLFlBQVk7QUFDZCxHQUlDLDYzQkFtQkE7QUFnRkgsOENBQThDO0FBQzlDVixxREFBTUEsQ0FBQztJQUFFRztBQUFvQjtBQWNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvbWF0ZXJpYWwudHN4P2M5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbWF0ZXJpYWxzLnRzeFxuXCJ1c2UgY2xpZW50XCI7XG5cbi8vIEltcG9ydCBuZWNlc3NhcnkgZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiQHJlYWN0LXRocmVlL2ZpYmVyXCI7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZHJlaVwiO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5cbi8vIENyZWF0ZSBhIHNoYWRlciBtYXRlcmlhbCBmb3Igbm9pc2UgZWZmZWN0XG4vLyBzaGFkZXJNYXRlcmlhbCB0YWtlcyB0aHJlZSBhcmd1bWVudHM6IHVuaWZvcm1zLCB2ZXJ0ZXggc2hhZGVyLCBhbmQgZnJhZ21lbnQgc2hhZGVyXG5jb25zdCBOb2lzZVNoYWRlck1hdGVyaWFsID0gc2hhZGVyTWF0ZXJpYWwoXG4gIC8vIDEuIFVuaWZvcm1zOiB2YWx1ZXMgcGFzc2VkIGZyb20gSlMgdG8gc2hhZGVyXG4gIHtcbiAgICB0aW1lOiAwLCAvLyBhbmltYXRpbmcgdGltZSBmb3IgbW92aW5nIG5vaXNlXG4gICAgY29sb3I6IG5ldyBUSFJFRS5Db2xvcigwLjAsIDAuMCwgMC4wKSwgLy8gYmFzZSBjb2xvcnMgKFJHQilcbiAgICBwb3NpdGlvbkluZGV4OiBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKSwgLy8gY3VycmVudCBjdWJlJ3MgZ3JpZCBwb3NpdGlvblxuICAgIHRvdGFsQ3ViZXM6IG5ldyBUSFJFRS5WZWN0b3IyKDUwLCA1MCksIC8vIGdyaWQgZGltZW5zaW9uc1xuICAgIGRlcHRoSW5kZXg6IDAsIC8vIHotbGF5ZXIgaW5kZXhcbiAgfSxcblxuICAvLyAyLiBWZXJ0ZXggU2hhZGVyOiBwcm9jZXNzZXMgZ2VvXG5cbiAgYFxuICB2YXJ5aW5nIHZlYzIgdlV2OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVVYgY29vcmRzIGZvciB0ZXh0dXJlcyYgMmQgZWZmZWN0cyBcbiAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cmZhY2Ugbm9ybXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsgICAgICAgICAgICAgICAgICAgLy8gY2FtLXJlbGF0aXZlIHBvc2l0aW9uIC0gdmlldy1kZXBlbmRlbnQgZWZmZWN0cyBcbiAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOyAgICAgICAgICAgICAgICAgIC8vIHdvcmxkIHNwYWNlIHBvc2l0aW9uIFxuICBcbiAgdm9pZCBtYWluKCkge1xuICAgIHZVdiA9IHV2OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyBVViBjb29yZHMgXG4gICAgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpOyAvLyBjYWxjdWxhdGUgbm9ybWFscyBcbiAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7ICAgICAvLyBjYWxjIHdvcmxkIHBvc2l0aW9uIGZvciBsaWdodHMgXG4gICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApOyAgICAvLyBjYWxjIHZpZXcgc3BhY2UgcG9zaXRpb24gXG4gICAgdlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOyAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgdmVydGV4IHBvc2l0aW9uIFxuICB9XG5gLFxuXG4gIC8vIDMuIEZyYWdtZW50IFNoYWRlcjogSGFuZGxlcyB0aGUgY29sb3IvcGl4ZWwgZGF0YVxuICAvLyBUaGlzIGNyZWF0ZXMgb3VyIG5vaXNlIHBhdHRlcm4gYW5kIGdyYWRpZW50IGVmZmVjdFxuICBgXG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgIHVuaWZvcm0gdmVjMiBwb3NpdGlvbkluZGV4O1xuICAgIHVuaWZvcm0gdmVjMiB0b3RhbEN1YmVzOyAgLy8gTWFrZSBzdXJlIHVuaWZvcm0gaXMgZGVjbGFyZWRcbiAgICB1bmlmb3JtIGZsb2F0IGRlcHRoSW5kZXg7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xuICAgIHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xuICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcblxuICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIHJhbmRvbSBub2lzZSBcbiAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KHAueHksIHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzMTIzKTtcbiAgICB9XG5cbiAgICBcbiAgICB2ZWMzIGdldEJhc2VDb2xvcih2ZWMyIHBvc2l0aW9uLCBmbG9hdCBkZXB0aCkgeyAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBjb2xvciBiYXNlZCBvZmYgcG9zaXRpb24gJiBkZXB0aCBcbiAgICB2ZWMyIG5vcm1hbGl6ZWRQb3MgPSBwb3NpdGlvbiAvIHRvdGFsQ3ViZXM7ICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGdyaWQgdG8gMC0xIHJhbmdlIFxuXG4vLyBkZWZpbmUgdGhlIGNvbG9ycyBmb3IgZWFjaCBkZXB0aCBsYXllciBcbiAgICB2ZWMzIGNvbG9yc1szXSA9IHZlYzNbM10oXG4gICAgICAgIHZlYzMoMC4wLCAwLjUsIDAuMyksICAvLyBsYXllciAxXG4gICAgICAgIHZlYzMoMC40LCAwLjAsIDAuOCksICAvLyBsYXllciAyIChmaXhlZCAwLjAuIHRvIDAuMClcbiAgICAgICAgdmVjMygwLjgsIDAuMCwgMC4wKSAgIC8vIGxheWVyIDNcbiAgICAgICk7XG5cbi8vIGdldCB0aGUgYmFzZSBjb2xvciBmb3IgdGhlIGN1cnJlbnQgZGVwdGggXG4gICAgICB2ZWMzIGJhc2VDb2xvcjEgPSBjb2xvcnNbaW50KGRlcHRoKV07XG4gICAgLy8gbGlnaHRlciB2YXJpYXRpb25zIFxuICAgICAgdmVjMyBiYXNlQ29sb3IyID0gYmFzZUNvbG9yMSArIHZlYzMoMC4yLCAwLjIsIDAuMik7XG4gICAgICB2ZWMzIGJhc2VDb2xvcjMgPSBiYXNlQ29sb3IyICsgdmVjMygwLjIsIDAuMiwgMC4yKTtcbiAgICAgIFxuLy8gY3JlYXRlIHRoZSBncmFkaWVudHMgXG4gICAgICB2ZWMzIGhvcml6b250YWxHcmFkaWVudCA9IG1peChiYXNlQ29sb3IxLCBiYXNlQ29sb3IyLCBub3JtYWxpemVkUG9zLngpO1xuICAgICAgdmVjMyB2ZXJ0aWNhbEdyYWRpZW50ID0gbWl4KGJhc2VDb2xvcjIsIGJhc2VDb2xvcjMsIG5vcm1hbGl6ZWRQb3MueSk7XG5cbiAgICAgIHJldHVybiBtaXgoaG9yaXpvbnRhbEdyYWRpZW50LCB2ZXJ0aWNhbEdyYWRpZW50LCAwLjUpO1xuICAgIH1cblxuXG5cbiAgICB2b2lkIG1haW4oKSB7XG5cbiAgICBcbi8vIDEtIGJhc2ljIHNldHVwOiBwcmVwYXJlIG5vcm1hbCBhbmQgdmlldyB2ZWN0b3JzIGZvciBsaWdodGluZyBcbiAgICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKHZOb3JtYWwpO1xuICAgICAgdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKHZWaWV3UG9zaXRpb24pO1xuICAgICAgXG4vLyAyLSBDT0xPUiBHRU4hIV9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuLy8gYWRkIG5vaXNlIHRvIGJhc2UgY29sb3IgXG4gICAgICB2ZWMzIGJhc2VDb2xvciA9IGdldEJhc2VDb2xvcihwb3NpdGlvbkluZGV4LCBkZXB0aEluZGV4KTtcbiAgICAgIGZsb2F0IG4gPSBub2lzZSh2VXYgKiAxMC4wICsgdGltZSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRlIG5vaXNlIFxuICAgICAgXG4gICAgICB2ZWMzIGxpZ2h0ZXJDb2xvciA9IGJhc2VDb2xvciArIHZlYzMoMC4yKTtcbiAgICAgIHZlYzMgY29sb3IgPSBtaXgoYmFzZUNvbG9yLCBsaWdodGVyQ29sb3IsIG4pO1xuXG4vLyAzLSBsaWdodCBwb3NpdGlvbjogY2FsY3VsYXRlIGxpZ2h0cyBcbiAgICAgIHZlYzMgbGlnaHRQb3NpdGlvbiA9IHZlYzMoOTAuMCwgMTAuMCwgMjAuMCk7XG4gICAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKGxpZ2h0UG9zaXRpb24gLSB2V29ybGRQb3NpdGlvbik7XG4gICAgICBcbi8vIDQtIGRpZmZ1c2UgbGlnaHRpbmc6IGhvdyBsaWdodCBhZmZlY3RzIHN1cmZhY2UgXG4gICAgICBmbG9hdCBkaWZmID0gbWF4KGRvdChub3JtYWwsIGxpZ2h0RGlyKSwgMC4wKTtcbiAgICAgIHZlYzMgZGlmZnVzZSA9IGNvbG9yICogZGlmZjtcbiAgICAgIFxuLy8gNS0gYWRkcmVzcyBhbWJpZW50IGxpZ2h0aW5nIFxuICAgICAgdmVjMyBhbWJpZW50ID0gY29sb3IgKiAwLjM7XG4gICAgICBcbi8vIDYtIHNwZWN1bGFyIGhpZ2hsaWdodHMgYW5kIHJlZmVsY3Rpb25zIFxuICAgICAgdmVjMyByZWZsZWN0RGlyID0gcmVmbGVjdCgtbGlnaHREaXIsIG5vcm1hbCk7XG4gICAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3Qodmlld0RpciwgcmVmbGVjdERpciksIDAuMCksIDMyLjApO1xuICAgICAgdmVjMyBzcGVjdWxhciA9IHZlYzMoMC41KSAqIHNwZWM7XG4gICAgXG4vLyA3IC0gY29tcG9zaXRpb246IGNvbWJpbmUgYWxsIGxpZ2h0aW5nIGNvbXBvbmVudHMgXG4gICAgICB2ZWMzIGZpbmFsQ29sb3IgPSBhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyOyAgIFxuLy8gb3V0cHV0IGZpbmFsIGNvbG9yIHdpdGggYWxwaGE9MS4wIFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChmaW5hbENvbG9yLCAxLjApO1xuICAgIH1cbiAgYFxuKTtcblxuLy8gbWFrZSBtYXRlcmlhbCBhdmFpYmFsZSBpbiBSZWFjdCBUaHJlZSBGaWJlclxuZXh0ZW5kKHsgTm9pc2VTaGFkZXJNYXRlcmlhbCB9KTtcblxuLy8gQWRkIFR5cGVTY3JpcHQgc3VwcG9ydCBmb3IgdGhlIGN1c3RvbSBtYXRlcmlhbCBpbiBKU1hcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgbmFtZXNwYWNlIEpTWCB7XG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIG5vaXNlU2hhZGVyTWF0ZXJpYWw6IGFueTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IGZvciB1c2UgaW4gb3RoZXIgY29tcG9uZW50c1xuZXhwb3J0IHR5cGUgTm9pc2VTaGFkZXJNYXRlcmlhbEltcGwgPSB0eXBlb2YgTm9pc2VTaGFkZXJNYXRlcmlhbDtcblxuZXhwb3J0IHsgTm9pc2VTaGFkZXJNYXRlcmlhbCB9O1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsInNoYWRlck1hdGVyaWFsIiwiVEhSRUUiLCJOb2lzZVNoYWRlck1hdGVyaWFsIiwidGltZSIsImNvbG9yIiwiQ29sb3IiLCJwb3NpdGlvbkluZGV4IiwiVmVjdG9yMiIsInRvdGFsQ3ViZXMiLCJkZXB0aEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/material.tsx\n"));

/***/ })

});